# JVM

## JVM模型图

![JVM](JVM.png)

### 1、程序计数器（Program Counter Register）

每个线程都有一个程序计数器，是线程私有的，用来指向下一条需要执行的字节码指令，分支，循环，跳转和异常处理线程恢复都依赖这个计数器完成。

若执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码地址；若正在执行的是Native方法，这个计数器值为空。

### 2、Java虚拟机栈

用来描述Java方法执行时的内存模型，每个方法在执行时会创建一个栈帧(局部变量表、操作数栈、动态链接、方法出口信息)。

设置Java虚拟机栈大小的方式-Xss1m:表示每个线程栈的大小为1m。

![javastack](JavaStack.png)

详解：

- 局部变量表
  - 是一组变量值存储空间，用于存放方法参数和方法中的局部变量，在Java程序被编译为Class文件时，局部变量表所占用的存储空间已经被确定，存储到了CODE属性的max_locals中。
- 操作数栈
  - 同局部变量表一样，操作数的最大深度也是在编译期被写入Code属性的max_stacks中，操作数栈的数据可以是任意Java类型，32位数据占容量1，64位数据占容量2。当一个方法在开始执行的时候，操作数栈是空的，在做算术运算时是基于操作数栈进行的，在方法中调用其他方法是通过操作数栈进行参数传递。
  - Java虚拟机解释执行引擎成为“基于栈的执行引擎”，这个栈指的就是操作数栈。
- 动态链接
  - 没看明白，仅知道每一个栈帧包含指向运行时常量池中属于该栈帧方法的引用，用来支持方法调用过程中的动态链接。可能需要通读第六章后再来理解。
- 返回地址
  - 在方法退出时，需要返回到方法被调用的位置，存在PC计数器中。
    - 方法退出包含正常完成退出和异常完成退出，异常完成退出不会给上层调用者产生任何返回值。
  - 方法退出的过程实际就是把当前栈帧出栈，可能包含的操作有：恢复上层调用方法的局部变量表和操作数栈，把返回值(若有)压入操作数栈中，调整PC计数器的以指向方法调用后的下一条指令。

两种异常：

- StackOverFlowError:如果线程请求的栈深度大于虚拟机所允许的最大深度。
- OutOfMemoryError:若虚拟机能够动态扩展时，当虚拟机无法申请到足够内存。

### 3、本地方法栈

功能和Java虚拟机栈相似，不过本地方法栈为使用到的Native方法服务。Sun HotSpot直接将本地方法栈和虚拟机栈合二为一。

### 4、Java堆

 ![QQ截图20200728105442](QQ截图20200728105442.png)

Java8取消了之前的“永久代”，取而代之的是“元空间”——**Metaspace**，两者本质是一样的。“永久代”使用的是JVM的堆内存，而“元空间”是直接使用的本机物理内存。

通过-Xms和-Xmx控制Java堆初始大小和最大大小。

Heap，一个JVM只有一个堆内存，是所有线程共享的，堆内存的大小是可以调节的。

堆内存中还要细分为三个区域：

- 新生区（伊甸园区）

  - 类：诞生、应用和垃圾回收
  - 所有的对象都是在伊甸园区new出来的

- 老年区

- 永久区

  `这个区域常驻内存，用来存放JDK自身携带的Class对象。Interface元数据，存储的是Java运行时的一些环境或类信息`

  - jdk1.6之前：永久代，常量池在方法区中
  - jdk1.7：永久代，但是慢慢的退化了，去永久代，常量池在堆中。
  - jdk1.8之后：无永久代，常量池在元空间

99%的对象都是临时对象。

GC垃圾回收主要发生在伊甸园区和老年区

假设内存满了，OOM，堆内存不够！java.lang.OutOfMemoryError:Java heap space

在JDK8以后，永久区改名了===》元空间：逻辑上存在物理上不存在，因为新生代和老年代的物理内存相加就等于堆内存

**OOM**

- 1、尝试扩大堆内存
- 2、分析内存，看哪个地方出现问题 

OOM故障排错

- 使用内存快照工具分析出错在第几行，插件排错：MAT、Jprofiler
- 源码Debug

MAT和Jprofiler作用：

- 分析Dump内存文件，快速定位内存泄露
- 获得堆中的数据
- 获得大的对象

**Jprofiler排错**

1.在idea中安装Jprofiler插件，并安装Jprofiler客户端。

2.编一个demo，设置-XX:+HeapDumpOnOutOfMemoryError使得运行时dump出相关错误文件

3.用Jprofiler打开该文件，可以看到哪个对象占用最多的堆内存进行排错。

![oom](oom.png)

### 5、方法区

方法区和堆一样，是线程共享的，它用于存放已被虚拟机加载的类信息、常量、静态变量和即时编译器编译后的代码(热点代码会被JIT编译成机器码，从而提高效率)。有个别名Not-Heap，为了和Java堆区分，方法区并不等于永久代，本质两者并不等价，HotSpot团队使用永久代实现方法区，能够省去专门为方法区编写内存管理代码的工作。

- JDK1.7之前：方法区相当于永久代，存放**类信息、常量、静态变量和即时编译器编译后的代码**。
- JDK1.7：仍有永久代，但部分数据迁移到了Java堆和本地内存中，符号引用(如java.util.Scanner)转移到本地内存，字符串常量池转移到Java堆中
- JDK1.8：仍保留方法区的概念，但永久代改成了元空间。
- 垃圾回收目标：常量池的回收(1.6之前)和类型的卸载，但GC的效果不太能令人满意，也会跑出OOM。

#### 回收方发区

GC在方法区回收两部分：废弃常量和无用的类。

### 6、运行时常量池

### 7、直接内存

## JVM中的直接引用和符号引用

在JVM中，类从被加载到虚拟机内存中开始，到卸载出内存为止；它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。而解析阶段即是虚拟机将常量池内的**符号引用**替换为**直接引用**的过程。

1.符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

2.直接引用：

 直接引用可以是

（1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）

（2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）

（3）一个能间接定位到目标的句柄

直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。

## 对象的创建

### 双亲委派机制

## JVM调优



## 三种JVM

Sun公司：`HotSpot`

BEA:`JRockit`

IBM：`J9 VM`



## GC算法

### **引用计数法**

- JVM一般不采用该方法。
- 会有一个引用计数器记录对象被使用的次数，若计数较少会优先被GC。
- 主流的Java虚拟机没有采用引用计数算法，原因是很难解决对象之间的循环引用问题

### 可达性分析算法

用来判断对象是否存活，从GC Roots对象节点向下遍历形成引用链，若某个对在不再引用链上说明该对象不可达，则该对象可以认为已经死亡。

GC Roots对象包括

- 虚拟机栈中本地方法变量表中的引用的对象
- 方法区中静态变量引用的对象
- 方法区中常量引用的对象(1.8之后在元空间)
- 本地方法栈中JNI引用的对象

### 引用

- 强引用
  - 不可GC，若内存不够就OOM

- 软引用
  - 若内存够则不会被GC，内存不够了再GC，若内存还不够则OOM

- 弱引用
  - 下一次GC一定会被清除

- 虚引用
  - 对对象的GC没有任何影响，作用就是为了跟踪对象的垃圾回收状况。

### **标记清除算法**

最基础的收集算法是“标记-清除”(Mark-Sweep)算法。

同名字，分为两个阶段：

- 标记
  - 标记出需要回收的对象
- 清除
  - 标记完成后，统一回收被标记的对象

说它是最基础的算法，是由于后续算法都是针对它的不足而进行改进的。

缺点：

- 标记和清除的效率这两个过程效率不高
- 会产生内存碎片

![image-20200811141711677](image-20200811141711677.png)

### **复制算法**

- 新生代98%的对象都是“朝生夕死”，因此将新生代分为一个Eden和两个Survivor区，比例为8:1。

- 复制算法发生在新生代区域
- 触发轻GC的时候，会触发一次复制算法，将幸存区的from中存活的对象复制到to，此时from变成to，to变成from。
- 如何分辨谁是to？谁空谁是to。

- 可以通过-XX:MaxTenuringThreshold=15设置一个对象进入老年代的时间，经历15次GC还存活的对象进入老年区。当老年区满做一次Full GC时该对象才可能被清除。
- 优点：没有内存碎片
- 缺点：多用一个幸存区空间，在对象存活率较高时，复制算法效率低。
- 复制算法最佳使用场景：对象存活的较低的时候，因此用于新生区。

![image-20200811142602475](image-20200811142602475.png)

### 标记-整理算法

第一阶段同标记-清除算法。

第二阶段整理不是清除掉可回收对象，而是让存活对象向一端移动，然后直接清理掉端边界以外的内存。

优点：不用浪费内存，没有内存碎片。

![image-20200811143143699](image-20200811143143699.png)

### 分代收集算法

将Java堆分为新生代和老年代：

- 新生代：
  - 由于对象存活率低，采用复制算法

- 老年代：
  - 对象存活率高，因此采用“标记-清除”或“标记-整理”算法。